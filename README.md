# Лабораторная работа 4. Реализация алгоритма «Best Fit» выделения участков памяти по запросу

## 1. Задание

Необходимо разработать компонент для заданной архитектуры (ARM) и платформы (Eco OS), реализующий стратегию управления динамической памятью Best Fit.

## 2. Реализуемый алгоритм

Best Fit - стратегия, при которой для запроса `reqSize` выбирается свободный блок минимального размера, удовлетворяющий условию `blockSize >= reqSize`. Такой подход уменьшает потери в выбранном блоке (внутреннюю фрагментацию), однако, как правило, требует полного просмотра списка свободных блоков при каждом выделении памяти.

Суть алгоритма:

* рассматриваются все свободные блоки с размером не меньше `size`;
* выбирается блок с минимальным остатком `waste = blockSize - size`;
* при точном совпадении (`waste == 0`) дальнейший поиск можно завершить досрочно, так как лучший кандидат уже найден.

Недостатком стратегии Best Fit является линейная сложность поиска подходящего блока, однако в рамках данной лабораторной работы приоритетом является корректность выбора, а не оптимизация времени выполнения.

Перед реализацией была изучена классическая схема работы алгоритма Best Fit и его отличия от стратегий First Fit и Next Fit. Это позволило корректно определить критерий выбора блока и сформировать тесты, проверяющие именно особенности Best Fit, а не общее поведение аллокатора.

## 3. Реализация

Реализация выполнена в виде bare-metal компонента для Eco OS и запускается на эмуляторе QEMU в режиме полной эмуляции платформы ARM (Raspberry Pi 3). Загрузка осуществляется напрямую через параметр -kernel с использованием образа kernel8.img.

### 3.1 Структура данных

Heap представлен двусвязным списком блоков. Метаданные каждого блока располагаются непосредственно перед пользовательской областью памяти. Указатель, возвращаемый функцией `Alloc`, указывает на начало полезной области.

Блок памяти описывается структурой `HeapBlock`:

```c
typedef struct HeapBlock {
    struct HeapBlock* next;
    struct HeapBlock* prev;
    uint32_t dataSize;
    uint8_t  freeFlag;
} HeapBlock;
```

`dataSize` - размер полезной области (payload) в байтах.
`freeFlag` - признак свободного или занятого блока.

### 3.2 Инициализация heap

При инициализации менеджера памяти весь выделенный диапазон размечается как один большой свободный блок, который становится головой списка блоков.

При тестировании для heap выделяется 512 КБ памяти.

### 3.3 Выделение памяти (Alloc)

Функция `Alloc` реализует стратегию Best Fit и выполняет следующие шаги:

* выравнивает размер запроса по `sizeof(voidptr_t)`;
* проходит по списку блоков и выбирает свободный блок с минимальным остатком `waste`;
* при необходимости выполняет разделение блока (splitting), если оставшаяся часть достаточно велика для размещения нового заголовка и минимальной полезной области;
* помечает выбранный блок как занятый и возвращает указатель на память после заголовка.

### 3.4 Освобождение памяти (Free)

Функция `Free`:

* выполняет базовую проверку, что переданный указатель относится к диапазону heap;
* содержит защиту от повторного освобождения одного и того же блока (double free);
* помечает блок как свободный;
* выполняет объединение (coalescing) со смежными свободными блоками: сначала вправо цепочкой, затем влево и повторно вправо для корректного объединения серии соседних свободных блоков.

### 3.5 Изменение размера блока (Realloc)

Функция `Realloc` поддерживает следующие сценарии:

* уменьшение размера блока на месте с возможным отделением хвостовой части (splitting);
* попытку расширения блока на месте за счёт следующего свободного блока;
* если расширение невозможно - выделяется новый блок, данные копируются, а старый блок освобождается.

### 3.6 Дополнительные операции Copy, Fill и Compare

Реализованы вспомогательные функции копирования, заполнения и сравнения памяти. Они используются как самим компонентом (например, в `Realloc`), так и тестами. Функция копирования корректно работает при перекрытии диапазонов памяти.

## 4. Тестирование

Цель тестирования - создать контролируемые ситуации с несколькими свободными блоками различных размеров и проверить адрес, возвращаемый функцией `Alloc`. Сравнение возвращаемых адресов используется как основной критерий корректности, так как оно однозначно показывает, какой именно свободный блок был выбран алгоритмом.
Это позволяет убедиться, что выбор действительно соответствует стратегии Best Fit.

### Разработанные тесты:

#### TEST 1: Best Fit (two free blocks) minimal remainder

Создаются два свободных блока разных размеров. Проверяется, что запрос размещается в меньшем из подходящих блоков, то есть выбирается кандидат с минимальным остатком.

#### TEST 2: Best Fit full scan of free blocks

Формируется ситуация с четырьмя свободными блоками различных размеров, разделёнными занятыми блоками. Проверяется, что алгоритм не останавливается на первом подходящем варианте, а выбирает лучший кандидат после просмотра всего списка.

#### TEST 3: Best Fit exact-fit priority

Создаётся ситуация, где среди свободных блоков присутствует точное совпадение по размеру запроса. Проверяется, что выбирается именно этот блок с нулевым остатком.

#### TEST 4: Best Fit uses split remainder

Проверяется корректность разделения блока и повторного использования остатка. После выделения памяти из большого блока остаётся свободная хвостовая часть, и следующий небольшой запрос должен размещаться именно в ней, а не в другом крупном свободном блоке.

#### TEST 5: Best Fit after coalescing

Проверяется объединение нескольких смежных свободных блоков при освобождении и последующее выделение из объединённой области. Запрос должен получить адрес начала объединённого блока.

#### TEST 6: Best Fit deterministic choice on equal blocks

Создаётся ситуация с двумя одинаково подходящими свободными блоками (одинаковый остаток). Проверяется детерминированность поведения: при равенстве выбирается первый встретившийся блок при линейном проходе списка.

### Результаты тестирования
<img width="858" height="712" alt="image" src="https://github.com/user-attachments/assets/453dfcfc-9b54-44e7-8fce-3223464b08e0" />

## 5. Вывод

В рамках лабораторной работы был реализован компонент управления динамической памятью для Eco OS со стратегией Best Fit. Реализация поддерживает выбор наиболее подходящего свободного блока, разделение блоков при выделении, объединение смежных свободных блоков при освобождении, а также корректную работу `Realloc` (уменьшение, попытка расширения на месте или перенос с копированием).

Результаты тестирования подтверждают корректность реализации алгоритма Best Fit и демонстрируют особенности алгоритма Best Fit по сравнению с другими стратегиями.

Таким образом, поставленная в задании задача по реализации алгоритма Best Fit в виде bare-metal компонента для платформы Eco OS, запускаемого на эмуляторе QEMU, выполнена в полном объёме.
